<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Mit tett értünk Nyomasek Bobó?</title>

<style type="text/css">
pre {
    background: lightgrey; 
    margin: 0.1em 0 0.1em 0;
    padding-left: 1em; }
div, p { margin: 0 0 1em 0; }
span.quote { 
    background: lightgrey; font-family: monospace; 
    padding-left: 1px; padding-right: 1px; }
</style>
</head>
<body>

<div><b><a name="Q0032">K:</a></b> Metakérdés: egy konkrét személyről van itt szó?<br>
<b>V:</b> Természetesen nem, Bobó (korábban más név állt itt, de rájöttem, hogy az valós
személyeket sérthet) a mindnyájunk lelkében élő <i>ihletett programozó,</i>
aki nem tervez, nem gondolkozik,
csak lelkesen beleveti magát a munkába, aztán utána az özönvíz.<br>
<b>K:</b> Csak ennyi?<br>
<b>V:</b> Kell még hozzá némi egészséges
<a href="https://hu.wikipedia.org/wiki/H%C3%BCbrisz">hübrisz,</a>
ami nem engedi, hogy a hibáinkat elismerjük és javítsuk.<br>
</div>

<div><b><a name="Q0001">K:</a></b> Mit tett értünk Nyomasek Bobó?<br>
<b>V:</b> Ő erőltette a szóközt tartalmazó fájl- és könyvtárneveket, mint "Program Files" és "Documents and Settings".
</div>

<div><b><a name="Q0036">K:</a></b> De ha azt leszámítjuk, akkor mit tett a fájlnevekért?<br>
<b>V:</b> Támogatta és ajánlotta az ékezetes betűk és speciális jelek használatát a fájlnevekben,
az ő sugallatára születnek a <span class="quote">Kedves Jenő Bácsi!.docx</span>-szerű fájlnevek.
</div>

<div><b><a name="Q0002">K:</a></b> Na jó, de azon kívül?<br>
<b>V:</b> Ő találta ki, hogy a 64-bites Windows-komponensek a System32 könyvtárba kerüljenek,
azoknak a kedvéért, akik képesek a 32-bites programjukat 64-bitesre átalakítani,
de az meghaladja a képességeiket, hogy ezen átalakítás során a  programjukban a 'system32' könyvtárnév
összes előfordulását 'system64'-re cseréljék.
</div>

<div><b><a name="Q0003">K:</a></b> Na jó, de azon kívül?<br>
<b>V:</b> Az előbbiekkel kapcsolatban kitalálta azt is, hogy egy-egy könyvtár neve attól függjön,
hogy ki kérdezi, például 'c:\users' vagy 'c:\felhasználók'; 'c:\program files (x86)' vagy
'c:\program files'
</div>

<div><b><a name="Q0037">K:</a></b> De az <I>ismert fájlkiterjesztések elrejtése,</I>
na arról csak nem állítod, hogy nem volt jó ötlet tőle?<br>
<b>V:</b> Nagyon jó ötlet volt, a 
<a href="https://en.wikipedia.org/wiki/ILOVEYOU">loveletter</a>-szerű vírusok sokkal kevesebb kárt tudtak volna
okozni nélküle.<br>
<b>K:</b> Na jó, de legalább ki lehet kapcsolni az elrejtést...</br>
<b>V:</b> Kivéve a <span class="quote">.lnk</span> kiterjesztés elrejtését.</br>
<b>K:</b> Azt miért kivéve?</br>
<b>V:</b> Mert a képernyőn megjelenő ikonfeliratok a <span class="quote">Desktop</span> könyvtárban
lévő fájlneveken alapulnak, azok pedig *.lnk fájlok.
Márpedig furcsa lenne, ha a Sajátgép.lnk-szerű ikonok látszanának a desktopon.</br>
</div>

<div><b><a name="Q0038">K:</a></b> És az
<a href="https://en.wikipedia.org/wiki/Fork_(file_system)">alternatív adatstreamek</A> koncepciója,
arról csak elismered, hogy zseniális!<br>
<b>V:</b> A legmesszebbmenőkig. Mondjuk ne akard archiválni, vagy más fájlrendszerű partícióra átmásolni az ilyen fájlt,
mert elveszhetnek az alternatív streamek adatai.<br>
<b>K:</b> Jó, de akkor is remek dolog, hogy így a felhasználó "háta mögött" lehet adatokat tárolni
a fájljaiban!<br>
<b>V:</b> Kétségtelenül, de azért örömmel hallanék egy <I>nem</I> rosszhiszemű alkalmazást hozzá.
(Tehát nem vírusterjesztés, nem trójai program, nem másolásvédelem.)
</div>

<div><b><a name="Q0004">K:</a></b> De a fordítóprogramok fejlesztésében nem vett részt Bobó?<br>
<b>V:</b> Dehogynem, ő találta ki az UB-optimalizálást, vagyis hogy a compiler tudatosan
hibás kódot generálhat, ha 'úgy látja, hogy a kódban Undefined Behaviour (UB) van'
</div>

<div><b><a name="Q0005">K:</a></b> Na jó, de azon kívül?<br>
<b>V:</b> Továbbá a compiler megteheti, hogy egy 'memset'-et figyelmen kívül hagyjon, ha szerinte
a kérdéses memóriát azután már úgysem használja a program. (Biztonsági kérdések nem érdeklik a mi Bobónkat.)
</div>

<div><b><a name="Q0006">K:</a></b> De vajon a programozási technikák kifejlesztésében is részt vett?<br>
<b>V:</b> Hogyne, ő találta ki az exception-öket, illetve azok elődeit, például az ONERRORGOTO-t.
Zseniális invenció: a program X-pontján fellépő hibát a program Y-pontján kezeljük,
mert 'ott nyilván több információ áll rendelkezésünkre arról, hogy mi is lehetett a gond az X-ponton'.
</div>

<div><b><a name="Q0007">K:</a></b> De hát vannak olyan függvények/metódusok (pl. a konstruktorok),
amik nem tudnak 'hagyományosan' hibát jelezni!<br>
<b>V:</b> És mit gondolsz, ezeket ki találta ki?
</div>

<div><a name="Q0025"><b>K:</b></a> De mást nem tett a hibakezelésért?<br>
<b>V:</b> Ő találta ki <span class="quote">memcpy_s</span>, <span class="quote">strcpy_s</span>
szerű függvényeket, azok számára, akik nem tudnak egy hossz-ellenőrzést leprogramozni
(strlcpy-ről, snprintf-ről sem hallottak), de arra képesek,
hogy minden egyes ilyen <i>'safe'</i> hívás előtt meghívják a
<span class="quote">set_constraint_handler_s</span> függvényt.<br>
<b>K:</b> Miért nem elég egyszer meghívni, a program elején?<br>
<b>V:</b> Bobó is így gondolja, mivel a programjait egyedül fejleszti,
külső komponenseket nem használ. Egyébként eljutna arra a gondolatra, hogy tőle
független programrészek bármikor elállíthatják a handlert.<br>
<b>K:</b> Dehát ha nála a hibakezelés amúgy is annyiból áll, hogy <i>'álljunk le, baj van'?</i><br>
<b>V:</b> Bingó, ennyiből áll nála a hibakezelés.
</div>

<div><b><a name="Q0008">K:</a></b> De mit tett Bobó a C-programozásért?<br>
<b>V:</b> Ő találta ki az 'errno'-t. A felhasználói program a libc-n keresztül kezdeményez egy rendszerhívást,
a rendszerhívás visszaadja a hibakódot, a libc pedig, ahelyett hogy továbbítaná a hívónak,
egy globális változóba teszi. Persze a multithreading ekkor még
az álmok ködös birodalmában sem létezett.
</div>

<div><b><a name="Q0009">K:</a></b> Na jó, de azon kívül?<br>
<b>V:</b> Mit gondolsz, ki találta ki a zéró-terminált stringet?
</div>

<div><b><a name="Q0010">K:</a></b> Na jó, de azon kívül?<br>
<b>V:</b> Ő találta ki, hogy a nulla 'pointerként' nem feltétlenül csupa nulla bitet jelent, hanem esetleg
valamilyen platformfüggő értéket, ami adott esetben meggyorsítja a hibás memóriahivatkozások
leleplezését (pl AIX-on hagyományosan 0xdeadbeef értéket használnak ilyen értelemben).<br>
Amikor emlékeztetik arra, hogy memóriaterületeket
(amik persze pointereket is tartalmazhatnak) 'bzero'-val
vagy 'calloc'-kal szokás inicializálni, azt feleli: hát ne úgy csináljátok!<br>
<b>K:</b> És ha kitalált volna egy <span class="quote">INVALID_POINTER</span>
szerű szimbólumot, hogy az jelképezhesse platformfüggő invalid pointert?<br>
<b>V:</b> Sajnos ez nem jó: túl flexibilis, kompatibilis megoldás lenne.<br>
<b>K:</b> De még milyen előnye van ennek a nem-nulla nullának?<br>
<b>V:</b> Például szerencsésen elrontja az alábbi makrókat:<br>
<pre>
#define offsetof(T,F) ((size_t)((char *)&amp;(((T *)0)->F)))
#define sizeofrf(T,F) (sizeof(((T *)0)->F))
</pre>
<b>K:</b> Azért ezen lehet segíteni egy ügyes kivonással, ugye?<br>
<b>V:</b> Hogyne, de van annál Bobósabb megoldás is:<br>
<pre>
#define offsetof(TYPE, MEMBER) __builtin_offsetof (TYPE, MEMBER)
</pre>
<b>K:</b> Ez jó megoldás, nem?<br>
<b>V:</b> Annyira jó, hogy adott esetben ilyen üzenetet fakaszt belőle a
<span class="quote">clang</span>:
<pre>
offsetof (struct sockaddr_in, sin_addr.s_addr)
<U>warning: using extended field designator is an extension</U>
</pre>
<b>K:</b> Ez tulajdonképpen mit jelent?<br>
<b>V:</b> Azt, hogy Bobó addig halmozta egymásra a hibás döntéseket,
hogy végül neked kellene szégyenkezned, amiért egy nemtriviális esetre
is használni akarod az offsetof-ot.
</div>

<div><b><a name="Q0011">K:</a></b> Na jó, de azon kívül?<br>
<b>V:</b> Az a csodás ötlete támadt, hogy a 'NULL' vagyis a nulla-pointert jelentő szimbólum
esetleg ne pointer legyen, hanem adott esetben a felhasználó legyen szíves
<span class="quote">(void *)NULL</span> szerű csodákat alkotni, vagyis a nulla pointert
pointerré típuskényszeríteni.
</div>

<div><b><a name="Q0033">K:</a></b> Igen, de a libc fejlesztésében részt vett?<br>
<b>V:</b> A <span class="quote">gets</span> függvényre a legbüszkébb, de sok más eredménye is van,
például a függvények által visszaadott értékek terén, például hogy a <span class="quote">fgets</span>
siker esetén <i>nem</i> a beolvasott karakterek számát adja vissza.<br>
<b>K:</b> Ugyan, csak meg kell hívni az strlen-t...<br>
<b>V:</b> Ugye?! Hiszen <i>nem valószínű,</i> hogy az inputban
<a href="#Q0009">NUL-karakter</a> legyen...<br>
<b>K:</b> És hogy a <span class="quote">syslog(3)</span>-nak nincs visszatérési értéke
(vagyis ha eleve hibás paraméterekkel hívtam meg, arról sem kapok visszajelzést),
az is Bobóka érdeme?<br>
<b>V:</b> Bizonyám, és méghozzá <i>segítő jószéndékból:</i> ha lenne visszajelzés,
azt a hívó esetleg 'rosszul értelmezné'.
</div>

<div><b><a name="Q0012">K:</a></b> És a POSIX-szabványosítás, abban részt vett?<br>
<b>V:</b> Hogyne, az apróságokra is van gondja, például úgy döntött, hogy az
<span class="quote">usleep</span> feleslegessé vált,
hisz ott a <span class="quote">nanosleep</span>. 
(Arról Bobóka nem tud, hogy egyesek olyan programokat szeretnének írni,
amik régi, 'nanosleep' előtti gépeken is kell működjenek.)
</div>

<div><b><a name="Q0017">K:</a></b> És még milyen unixos szabványosításban segített?<br>
<b>V:</b> Itt van rögtön a terminálkezelés: az elmúlt ötven év nem volt elég ahhoz,
hogy kialakuljon az egyetértés, hogy a BackSpace gomb mit kellene csináljon:
eltünteni a kurzor előtt álló karaktert, vagy kiírni, hogy <span class="quote">^H</span>
, vagy kiírni, hogy <span class="quote">^?</span>.<br>
<b>K:</b> Ebben pontosan micsoda Bobóka személyes érdeme?<br>
<b>V:</b> Például meggyőzte a különféle linux-disztibútorokat, hogy a terminfo-adatbázis
csak azért van, hogy legyen mit meghekkelni.
</div>

<div><b><a name="Q0013">K:</a></b> De a Windows programozásban mit talált ki?<br>
<b>V:</b> Például az ő leleménye, hogy a 32-bites DLL-ek <I>nem</I> pozíciófüggetlen (PIC) kódot
tartalmaznak, így csak akkor lehet őket különböző processzek között megosztani, ha éppen sikerül
azonos memóriacímre elhelyezni a virtuális címtartományban.
</div>

<div><b><a name="Q0016">K:</a></b> De mást nem talált ki DLL-ügyben?<br>
<b>V:</b> De, azt a gyorsító fogást, hogy a DLL-beli függvények elérése ne csak név,
hanem azonosító szám (ordinal) alapján is történhessen.
Persze ezek a számok még a Microsoft saját DLL-jeiben sem maradnak állandók,
tehát mindenképp meg kell akadályozni, hogy a programunk így linkelődjön.
</div>

<div><b><a name="Q0014">K:</a></b> És még mit?<br>
<b>V:</b> Például azt, hogy a 'long' típus 32-bites maradt 64-bites módban is.
Ennek két fontos oka volt, az egyik az, hogy Unixban nem így van, a másik az,
hogy lehetnek olyanok, akiknek a 64-bitesre hosszabbodó 'long' gondot okozna.
Szerencse, hogy a 64-bitesre hosszabbodó WPARAM és LPARAM nem okoz
gondot senkinek.<br>
<b>K:</b> De lehet, hogy csak arra gondolt, hogy nem kevés munkájába kerülne
átnézni a különféle struktúrákat, hogy hány helyen használt
<span class="quote">LONG</span>-ot
<span class="quote">INT32</span> helyett
(vagy <span class="quote">ULONG</span>-ot
<span class="quote">DWORD</span> helyett).<br>
<b>V:</b> Nem mondod?!
</div>

<div><b><a name="Q0026">K:</a></b> De mit tett a Java-programozókért?<br>
<b>V:</b> Hát mit gondolsz, ki az, aki az egyik verzióban betesz a SE-be egy új
featúrát, mert trendi, a következőből meg kiveszi, mert elavult?</div>

<div><b><a name="Q0027">K:</a></b> De azon kívül semmit?<br>
<b>V:</b> Az ő leleménye volt az, hogy fordításkor a 
<span class="quote">\uXXXX</span> szekvenciák kifejtése a lexikális
elemzés <I>előtt</I> legyen, így például egy stringet le lehet zárni egy \u0022
szekvenciával, egy sort pedig egy \u000D szekvenciával.</div>

<div><b><a name="Q0015">K:</a></b> Az Oracle-adatbáziskezelő fejlesztésénél mit segített?<br>
<b>V:</b> Megengedte, hogy a <span class="quote">NLS_LANG</span> nevű környezeti változót a felhasználó szabadon beállítsa
bármire, de ez alól kivétel az <span class="quote">AL16UTF16</span> érték, arra nem szabad állítani.
Miért? Mert az a <span class="quote">NLS_NCHAR</span> változónak a szokásos értéke!</div>

<div><b><a name="Q0018">K:</a></b> És a PC-s hardware-ben nem segített?<br>
<b>V:</b> Nem-e? Az 8086-os CPU szegmens*16+offset elvű címzési rendszerét
egymaga csinálta!</div>

<div><b><a name="Q0019">K:</a></b> Na de azon kívül?<br>
<b>V:</b> A hard-diskek kezelésénél annyira ügyelt a bitekkel való takarékosságra,
hogy bele is szaladtunk az 504 megabájtos korlátba (C/H/S=1024/16/63),
aztán a 7.875 gigabájtos korlátba (1024/256/63), aztán a 127.5 gigabátjos korlátba (65536/16/255),
vagy választhatóan a 128 gigabájtos korlátba (28 bites lineáris cím).
(Egyes hardware/BIOS/OS verziók másféle korlátokkal szolgáltak, pl. 7.39 gigabájt (1024/240/63),
31.5 gigabájt (65536/16/63))</div>

<div><b><a name="Q0020">K:</a></b> Na jó, de azon kívül hol spórolt még a biteken?<br>
<b>V:</b> Az IBM System/360-as sorozatának 32-bites gépei csak 24 bitet használtak
a címzéshez (maximum 16 megabájt), a felső nyolc bitet Bobika jól ki tudta használni másra.
Jó mulatság volt azután mindent újracsinálni a /370 sorozatnál, ahol már 31 bit vett részt a címzésben.<br>
Ugyanezt a <a href="https://en.wikipedia.org/wiki/Mac_OS_memory_management">Macintoshnál</a>
is előadta, Motorola 680x0 processzoron.</div>

<div><b><a name="Q0021">K:</a></b> Na jó, de azon kívül hol spórolt még a biteken?<br>
<b>V:</b> Mit gondolsz, ki találta ki a 32-biten tárolt timestamp-et illetve fájlméretet?
(Lásd <a href="https://en.wikipedia.org/wiki/Year_2038_problem">Y2038-problem</a> illetve
<a href="https://en.wikipedia.org/wiki/Large-file_support">Large File Support</a>).
</div>

<div><b><a name="Q0022">K:</a></b> És más nem területen nem tett semmit a takarékosság érdekében?<br>
<b>V:</b> Dehogynem, az egész <a href="https://en.wikipedia.org/wiki/Year_2000_problem">Year2000</a>
mizéria nem lett volna, ha nem találja ki a hat karakteren tárolt dátumokat!</div>

<div><b><a name="Q0024">K:</a></b> De villamosmérnökként mit tett értünk?<br>
<b>V:</b> A villamosmérnökök szabványügyi testülete (IEEE) befogadta az
<a href="https://en.wikipedia.org/wiki/Ethernet_frame">Ethernet-keret</a> formátumát
802.3 néven, de a mi Bobónk javaslatára a 'típus' mezőt 'hossz'-ra változtatták.
Sajnos ezzel sem sikerült megakadályozni több protokoll párhuzamos használatát,
mivel a 'típus' definiált értékei (pl IP: 2048, IPv6: 34525) nagyobbak a 'hossz' maximumánál (1500).</div>

<div><b><a name="Q0023">K:</a></b> Na jó, de a számítástudományban nem jeleskedett?<br>
<b>V:</b> Például még 1975-ben kitalált egy ellenőrzőszám-képzési algoritmust,
ami egy tízjegyű számhoz rendel egy tizenegyedik ellenőrző számjegyet,
úgy hogy az véd egy számjegy elrontása ellen,
véd két szomszédos számjegy felcserélése ellen, de nem véd az utolsó számjegy és az ellenőrzőjegy
felcserélése ellen.</div>

<div><b><a name="Q0028">K:</a></b> Na de mit tett az Unicode érdekében?<br>
<b>V:</b> Ő döntött úgy, hogy 16 bit elegendő a világ összes karaktere számára
(kiegészítő adat <a href="https://en.wikipedia.org/wiki/Kanji#Total_number_of_kanji">itt</a>),
tehát az UCS-2BE lehet az univerzális formátum.
Vagy az UCS-2LE. Akkor már két univerzális formátum is van!
De legalább fix méretűek a karakterek, nem úgy mint az
<a href="https://tools.ietf.org/html/rfc2279">1-6 bájtos UTF-8</a> szekvenciák.<br>
Okos szavára hallgatott is a Microsoft, az IBM, az Oracle, a Sun és még sokan mások.<br>
Aztán valahogy kiderült, hogy 16 bit mégsem elegendő mindenre, tehát Nyomasek Bobó előállt
a <a href="http://lzsiga.users.sourceforge.net/ekezet.html#Q0129">helyettesítő párok</a> ötletével,
így lett az UTF-16LE meg az UTF-16BE.<br>
Így újra minden rendben, bár ettől kezdve a karakterek nem fix méretűek,
és az ábrázolható karaktertartomány kétmilliárdról egymillióra csökkent,
de ez sem baj, legalább az UTF-8 szekvenciák maximális hosszát is
<a href="https://tools.ietf.org/html/rfc3629">négyre lehetett csökkenteni.</a><br>
<b>K:</b> De legalább az UTF-32 esetén minden karakter fixen négy bájtos.<br>
<b>V:</b> Az biztos! Itt van például ez: &#x044E;&#x0301; (cyrillic small letter yu with acute)
&ndash; ez <i>kétszeresen</i> is négybájtos: az első négy a betű,
a második négy az ékezet rajta
[forrás: <a href="http://utf8everywhere.org/">http://utf8everywhere.org/</a>],
</div>

<div><b><a name="Q0029">K:</a></b> Na de a kis részletekkel nem törődött?<br>
<b>V:</b> Dehogynem, hála neki van egy csomó rosszul vagy sehogysem definiált
vezérlőkarakterünk; például a U+AD kódú <span class="quote">SHY</span> karakter,
ami igen hasznos funckció lenne sorkizárt szövegekbe feltélteles elválasztások
beillesztésére, ha a definíciója nem ez lenne: <I>ez a karakter egyes kontextusokban
feltételes elválasztást jelenthet.</I></div>

<div><b><a name="Q0030">K:</a></b> A big-endian platformon fejlesztőkért ugyan mit tett?<br>
<b>V:</b> Ügyesen felfedezte, hogy egyes esetekben különböző méretű integerek pointerei
helyettesíthetik egymást, pl. egy 'uint64_t' típusű változó címét használhatjuk olyankor,
amikor 'uint32_t *'-ot várnak tőlünk (persze előtte kinullázva), mivel a magasabb
helyiértékű bitek ugyis 'hátul' vannak. Mármint little-endian platformon. Big-endian platformon
ez nem működik, de tanulságos hibakereséshez vezet.</div>

<div><b><a name="Q0031">K:</a></b> Na jó, de még mit?<br>
<b>V:</b> Ezt a hibát úgy akarta jóvátenni, hogy bevette a C-szabványba, hogy különböző
méretű integerek pointerei közötti typecast <I>Undefined Behaviour.</I>
Ezt még kapcsold össze az <a href="#Q004"> UB-optimalizációval,</a>
és azt kapod, hogy adott esetben egy byte-sorrend megfordító függvényből
a fordító belátása szerint azt generál, amit csak akar, <I>'hiszen UB van benne!'</I></div>

<div><b><a name="Q0034">K:</a></b> Ugyan mit tett a lokalizáció érdekében?<br>
<b>V:</b> Hát szerinted kinek köszönhetjük az érthetetlenségig megmagyarított
szakkönyveket, a magyarra fordított programnyelveket (MS Office), a tizedespont helyett
a tizedesvesszőt?<br>
<b>K:</b> Speciel a tizedesvessző tök logikus, hiszen a felhasználók ahhoz vannak szokva.<br>
<b>V:</b> A felhasználók már tök jól hozzászoktak a tizedesponthoz, amikor Bobus
elkezdte a tizedesvesszőt erőltetni...<br>
<b>K:</b> Hát majd szépen mindenki átszokik a tizedesvesszőre, felhasználók és programozók
egyaránt...<br>
<b>V:</b> A programozók csak akkor szokhatnának át, ha a pontot és a vesszőt
teljesen megcséréljük (rosszabb esetben más írásjeleket is belekavarhatunk a dologba),
és így teremtjük meg az inkompatibilitás újabb csodáit, pl:
<pre>
for (rekord,fld= 1,0; rekord,fld<=3,0; rekord,fld += 0,5)
    printf ("%g". rekord,fld);
</pre>
</div>

<div><b><a name="Q0035">K:</a></b> De a dátumok kezeléséért nem tett semmit?<br>
<b>V:</b> Dehogynem, mikor észrevette, hogy a magyar dátum-sorrend (év-hónap-nap)
logikus, rendezésbarát, és még az ISO 8601 szabvánnyal is összhangban van,
akkor felhorgadt benne a világpolgár, és elkezdte a <i>külföldi dátumformátum</i>
használatát erőltetni.
Nem az ő hibája, hogy ilyen dolog, hogy <i>külföldi dátumformátum</i>
egyszerűen nem létezik, különféle kultúrkörök különféle formátumokat használnak
(pl. mm/dd/yy, dd/mm/yy), angol nyelvterületen például úgy kerülik el a félreértéseket,
hogy a hónap rövidítését betűkkel írják: <span class="quote">Nov 30 17:13:36 2018</span>).
</div>
</body>
</html>
